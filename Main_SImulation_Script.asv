% --- Main Simulation Script for Dual-Shelf Gantry System ---
%
% This script simulates a 3-axis gantry robot operating in an aisle
% between two storage shelves (Shelf A and Shelf B).
%
% It uses separate functions for:
% - Kinematics (fk_gantry, ik_gantry)
% - Environment Plotting (Environment_Plotting)
% - Movement/Animation (Movement_and_Animation)
%
% To run, place all .m files in the same MATLAB directory
% and execute this script.

clc; 
clear; 
close all;

disp('Initializing Dual-Shelf Gantry Simulation...');

% --- 1. ENVIRONMENT DIMENSIONS CONTROL PANEL ---
% Define all your dimensions here.
env.aisle_width = 4;        % Distance between the two shelves (m)
env.shelf_depth = 1.5;      % Depth of the shelves (m)
env.shelf_length = 9;       % Length of the shelves along the X-axis (m)
env.shelf_height = 6;       % Total height of the shelves (m)

% Compartment setup (for a 9x4 = 36 compartment shelf)
env.compartments_x = 9;     % Number of compartments along X
env.compartments_z = 4;     % Number of compartments along Z

% --- 1a. NEW: PHYSICS PARAMETERS ---
g = 9.81; % m/s^2
masses.m_parcel = 5;      % Mass of the parcel (kg)
masses.m_hoist = 10;      % Mass of the Z-axis hoist/gripper
masses.m_trolley = 25;    % Mass of the Y-axis trolley (moves Z-axis)
masses.m_bridge = 100;    % Mass of the X-axis bridge (moves Y-axis)

% NEW: Bin dimensions (Length, Width, Height)
bin_dims = [1.0, 1.0, 0.5]; % [L, W, H] centered on the end-effector

% --- 2. AUTOMATICALLY CALCULATED POSITIONS ---
% Shelf Y-positions (front faces)
env.shelf_A_y_pos = -env.aisle_width / 2; % Shelf A (Negative Y)
env.shelf_B_y_pos = env.aisle_width / 2;  % Shelf B (Positive Y)

% Compartment dimensions
comp_width = env.shelf_length / env.compartments_x;
comp_height = env.shelf_height / env.compartments_z;

% --- 3. TASK COORDINATES (THIS IS HOW YOU TWEAK THE TASK) ---
%
% --- Define the Target Parcel Location ---
% Pick a shelf:
target_shelf_y = env.shelf_A_y_pos; % Use env.shelf_A_y_pos or env.shelf_B_y_pos
% Pick a compartment (e.g., column 3, row 2)
target_comp_x_index = 3; % From 1 to env.compartments_x
target_comp_z_index = 2; % From 1 to env.compartments_z

% Calculate the 3D coordinate of that compartment's center
target_x = (target_comp_x_index - 0.5) * comp_width;
target_z = (target_comp_z_index - 0.5) * comp_height;
target_y_depth = target_shelf_y; % Position in middle of shelf depth

% This is the final [x,y,z] for the parcel
rack_pos = [target_x, target_y_depth, target_z];

% --- Define the Platform Location ---
% (In the middle of the aisle, halfway along its length, 1m high)
platform_pos = [env.shelf_length / 2, 0, 1];

% --- Define Safety and Home Positions ---
safe_height = env.shelf_height + 0.5; % Must be > shelf height
home_joints = [0, 0, safe_height]; % Home: (x=0, y=0, z=safe_height)

% --- 4. SETUP THE 3D PLOT ---
figure('Name', 'Gantry Kinematics Simulation', 'NumberTitle', 'off', 'Units', 'normalized', 'OuterPosition', [0.1 0.1 0.8 0.8]);
hold on;
%grid on;
axis equal; % Ensures 1:1:1 aspect ratio
view(120, 25); % New view angle to see down the aisle

% Set plot limits based on environment dimensions
max_x = env.shelf_length;
max_y_limit = (env.aisle_width / 2) + 0.5; % For plotting
max_z_limit = env.shelf_height + 1; % For plotting
xlim([0 max_x]);
ylim([-max_y_limit max_y_limit]);
zlim([0 max_z_limit]);

xlabel('X-axis (Aisle Length)');
ylabel('Y-axis (Aisle Width)');
zlabel('Z-axis (Height)');
title('Dual-Shelf Gantry Simulation'); % Static title

% --- NEW: PARAMETER TABLE ---
% Create a text box annotation on the right side of the figure
% [x, y, width, height] in normalized units
table_pos = [0.75, 0.5, 0.22, 0.35]; 
initial_table_str = {'-- DYNAMIC PARAMETERS --', 'Status: Initializing...'};
h_table_text = annotation('textbox', table_pos, 'String', initial_table_str, ...
    'FitBoxToText', 'off', 'BackgroundColor', 'w', ...
    'FontSize', 10, 'VerticalAlignment', 'top', 'Color', [0, 0, 0]);

% --- 5. PLOT STATIC ENVIRONMENT ---
% Pass the entire 'env' struct and get parcel handle
[h_parcel] = Environment_Plotting(env, rack_pos, platform_pos);

% --- 6. INITIALIZE GANTRY VISUALIZATION (New Model) ---
% Get initial EE position from home joint state using Forward Kinematics
current_pos = Forward_Kinematics_Model(home_joints);
px = current_pos(1);
py = current_pos(2);
pz = current_pos(3);

% --- NEW: Plot the gantry "bin" as a prism ---
h_bin = draw_prism(current_pos, bin_dims, 'b', 0.5); % Blue, 50% transparent

% Plot the gantry structure (Aisle-Spanning Model)
% h_structure(1) = Z-arm (vertical hoist)
% h_structure(2) = Y-trolley (cart on the bridge)
% h_structure(3) = X-bridge (spans aisle, moves along X-rail)
h_structure(1) = plot3([px px], [py py], [pz max_z_limit], 'k-', 'LineWidth', 2.5, 'Color', [0.3 0.3 0.3]);
h_structure(2) = plot3([px px], [py-0.2 py+0.2], [max_z_limit max_z_limit], 'k-', 'LineWidth', 4, 'Color', 'r');
h_structure(3) = plot3([px px], [-max_y_limit max_y_limit], [max_z_limit max_z_limit], 'k--', 'LineWidth', 2, 'Color', [0.5 0.5 0.5]);
% --- UPDATED LEGEND ---
legend(h_bin, 'Gantry Bin / Gripper', 'Location', 'northwest');


% --- 7. SIMULATION PARAMETERS ---
time_step = 0.05;  % Simulation time step
move_time = 2.0;   % Time for a long move
short_move_time = 1.0; % Time for up/down/sideways moves
is_holding_parcel = false; % State variable

% --- 7. SIMULATION PARAMETERS ---
time_step = 0.05;  % Simulation time step
move_time = 2.0;   % Time for a long move
short_move_time = 1.0; % Time for up/down/sideways moves
is_holding_parcel = false; % State variable

% --- 7a. NEW: ADD START BUTTON AND WAIT ---
disp('Simulation ready. Press "Start" in the figure window to begin.');
h_start_button = uicontrol('Style', 'pushbutton', 'String', 'Start Simulation', ...
                   'Units', 'normalized', ...
                   'Position', [0.8 0.05 0.15 0.05], ...
                   'Callback', 'uiresume(gcbf)');
uiwait(gcf); % Pause the script and wait for the button press
delete(h_start_button); % Remove the button after it's clicked
% --- 8. RUN THE NEW TASK SEQUENCE (Safer Logic) ---
disp('Starting task sequence...');
pause(1);

% 1. Move to Pre-Grasp position (correct X/Z, but center aisle Y=0)
disp('Moving to aisle position (X, Z)...');
pre_aisle_pos = [rack_pos(1), 0, rack_pos(3)];
current_pos = Movement_and_Animation(current_pos, pre_aisle_pos, move_time, time_step, ...
    h_bin, h_structure, max_y_limit, max_z_limit, bin_dims, ...
    h_parcel, is_holding_parcel, masses, g, h_table_text);

% 2. NEW: Simulate Parcel "Pull"
% The gantry waits while the parcel moves from the rack to the gantry
disp('Pulling parcel from shelf...');
start_parcel_pos = rack_pos;
end_parcel_pos = pre_aisle_pos;
T_pull = short_move_time;
time_vec_pull = 0:time_step:T_pull;
if time_vec_pull(end) ~= T_pull, time_vec_pull(end+1) = T_pull; end

for i = 1:length(time_vec_pull)
    t = time_vec_pull(i);
    s = 0.5 * (1 - cos(pi * t / T_pull));
    curr_parcel_pos = start_parcel_pos + s * (end_parcel_pos - start_parcel_pos);
    
    set(h_parcel, 'XData', curr_parcel_pos(1), ...
                   'YData', curr_parcel_pos(2), ...
                   'ZData', curr_parcel_pos(3));
    drawnow;
    pause(time_step/2);
end
set(h_parcel, 'XData', end_parcel_pos(1), 'YData', end_parcel_pos(2), 'ZData', end_parcel_pos(3));
drawnow;

% 3. Simulate Grasp
disp('Gripping parcel (Bin Red)...');
set(h_bin, 'FaceColor', 'r'); % Red = holding
is_holding_parcel = true; % Update state
pause(0.5);

% 4. Retract from shelf (Y-axis) back to center aisle
disp('Retracting from shelf... (Parcel Attached)');
% (No movement, just a logical step. current_pos is already correct)

% 5. Move to safe height (WITH PARCEL)
disp('Moving to safe height (with parcel)...');
safe_travel_pos = [rack_pos(1), 0, safe_height];
current_pos = Movement_and_Animation(current_pos, safe_travel_pos, short_move_time, time_step, ...
    h_bin, h_structure, max_y_limit, max_z_limit, bin_dims, ...
    h_parcel, is_holding_parcel, masses, g, h_table_text);

% 6. Move to pre-release position (above platform, center aisle) (WITH PARCEL)
disp('Moving to pre-release position (X) (with parcel)...');
pre_release_pos = [platform_pos(1), 0, safe_height];
current_pos = Movement_and_Animation(current_pos, pre_release_pos, move_time, time_step, ...
    h_bin, h_structure, max_y_limit, max_z_limit, bin_dims, ...
    h_parcel, is_holding_parcel, masses, g, h_table_text);

% 7. Move down to release (Z-axis) (WITH PARCEL)
disp('Moving down to release (with parcel)...');
release_pos = platform_pos;
current_pos = Movement_and_Animation(current_pos, release_pos, short_move_time, time_step, ...
    h_bin, h_structure, max_y_limit, max_z_limit, bin_dims, ...
    h_parcel, is_holding_parcel, masses, g, h_table_text);

% 8. Simulate Release
disp('Releasing parcel (Bin Blue)...');
set(h_bin, 'FaceColor', 'b'); % Blue = empty
is_holding_parcel = false; % Update state
% The parcel 'h_parcel' will now stay at 'release_pos'
pause(0.5);

% 9. Move up to safe height (EMPTY)
disp('Moving back to safe height (empty)...');
current_pos = Movement_and_Animation(current_pos, pre_release_pos, short_move_time, time_step, ...
    h_bin, h_structure, max_y_limit, max_z_limit, bin_dims, ...
    h_parcel, is_holding_parcel, masses, g, h_table_text);

% 10. Return to Home (EMPTY)
disp('Returning to home position (empty)...');
home_pos = Forward_Kinematics_Model(home_joints);
current_pos = Movement_and_Animation(current_pos, home_pos, move_time, time_step, ...
    h_bin, h_structure, max_y_limit, max_z_limit, bin_dims, ...
    h_parcel, is_holding_parcel, masses, g, h_table_text);

disp('Task Complete.');
final_table_str = {'-- DYNAMIC PARAMETERS --', 'Status: Task Complete.'};
set(h_table_text, 'String', final_table_str);

% --- End of Main Script ---


% --- NEW HELPER FUNCTION ---
function [h_patch] = draw_prism(center_pos, dims, color, alpha)
    % Calculates vertices and faces for a prism centered at center_pos
    %
    % Inputs:
    %   center_pos: [x, y, z]
    %   dims:       [L, W, H]
    %   color:      MATLAB color spec (e.g., 'b')
    %   alpha:      Transparency (0 to 1)
    
    L = dims(1);
    W = dims(2);
    H = dims(3);
    
    cx = center_pos(1);
    cy = center_pos(2);
    cz = center_pos(3);
    
    % Define 8 vertices
    verts = [
        cx-L/2, cy-W/2, cz-H/2; % 1
        cx+L/2, cy-W/2, cz-H/2; % 2
        cx+L/2, cy+W/2, cz-H/2; % 3
        cx-L/2, cy+W/2, cz-H/2; % 4
        cx-L/2, cy-W/2, cz+H/2; % 5
        cx+L/2, cy-W/2, cz+H/2; % 6
        cx+L/2, cy+W/2, cz+H/2; % 7
        cx-L/2, cy+W/2, cz+H/2  % 8
    ];

    % Define 6 faces
    faces = [
        1, 2, 3, 4; % Bottom
        5, 6, 7, 8; % Top
        1, 2, 6, 5; % Front
        2, 3, 7, 6; % Right
        3, 4, 8, 7; % Back
        4, 1, 5, 8  % Left
    ];

    % Draw the patch
    h_patch = patch('Vertices', verts, 'Faces', faces, ...
                    'FaceColor', color, 'FaceAlpha', alpha, ...
                    'EdgeColor', 'k');
end